---
title: "How do different factor affect the NBA players' salary"
subtitle: CREST GOLD
author:
  - name: "Chun Yin, Wong Jamin"
  - name: "Kwan Ho, Mok Jack"
  - name: "Cheuk Hei, Ng Adrian"
  - name: "King Yiu, Chow Kinson"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
bibliography: references.bib
csl: elsevier-harvard.csl
---

# Executive Summary
1. NBA player Salary based on their statistics
2. Use glm model
3. use neural network
4. xgboosting

# Introduction

## links to file:  
player_PGstats_2021.csv -- NBA players statistics per game in 2021-2022 season  
source: https://www.basketball-reference.com/leagues/NBA_2022_per_game.html  
player_Adstats_2021.csv -- NBA players advance statistics in 2021-2022 season
source: https://www.basketball-reference.com/leagues/NBA_2022_advanced.html  
salary2022.csv -- NBA players contract in 2022-2023 season onward  
source: https://www.basketball-reference.com/contracts/players.html  
bio.csv -- NBA player bio (height and weight)  
source: https://www.nba.com/stats/players/bio/?Season=2021-22&SeasonType=Regular%20Season&sort=PLAYER_NAME&dir=1  


# Loading and Exploring Data

## Loading libraries required
```{r setup, message=FALSE, warning=FALSE}
library(knitr)
library(plyr)
library(dplyr)
library(tidyr)
library(caret)
library(ggplot2)
library(corrplot)
library(stringr)
library(scales)
library(randomForest)
library(psych)
library(glmnet)
library(rpart)
library(lubridate)
library(plotly)
library(forcats)
library(ggExtra)
library(reshape2)
library(tree)
library(MASS)
library(Metrics)
opts_chunk$set(echo = TRUE, cache = TRUE)
opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE, fig.height = 6, fig.width = 9)
```

## Loading data files
```{r}
pgstats <- read.csv("files/2022/player_PGstats_2021.csv")
adstats <- read.csv("files/2022/player_Adstats_2021.csv")
salary <- read.csv("files/2022/salary2022.csv")
bio <- read.csv("files/2022/bio.csv")
```

## File description
### player_PGstats_2021.csv
NBA players statistics per game in 2021-2022 season  
source: https://www.basketball-reference.com/leagues/NBA_2022_per_game.html  
```{r}
dim(pgstats)
str(pgstats)
```
### player_Adstats_2021.csv
player_Adstats_2021.csv -- NBA players advance statistics in 2021-2022 season
source: https://www.basketball-reference.com/leagues/NBA_2022_advanced.html  
```{r}
dim(adstats)
str(adstats)
```

### salary2022.csv
salary2022.csv -- NBA players contract in 2022-2023 season onward  
source: https://www.basketball-reference.com/contracts/players.html  
```{r}
dim(salary)
str(salary)
```

### bio
bio.csv -- NBA player bio (height and weight)  
source: https://www.nba.com/stats/players/bio/?Season=2021-22&SeasonType=Regular%20Season&sort=PLAYER_NAME&dir=1  
```{r}
dim(bio)
str(bio)
```


# Preprocessing Data

## Merge data tables

I will merge the tables by their primary key (pgstats.player_id) and foreign key (salary.player_id) by inner join (only take the entries which exist). I will treat the players that received salary but have not played any game as outliers.
```{r}
merged <- merge(pgstats, adstats, by = c("player_id", "Tm"))
```
Since there is players that has changed team in the middle of the season, I will use the total stats (indicated by Tm = "TOT").  

```{r}
repeated <- names(which(table(merged$player_id) > 1))

for (i in 1:length(repeated))
{
  id <- repeated[i]
  
  use <- merged[which(merged$player_id == id & merged$Tm == "TOT"),]
  temp_tm <- merged$Tm[max(which(merged$player_id == id))]
  merged <- merged[merged$player_id != id,]
  merged <- rbind(merged, use)
  merged$Tm[merged$player_id == id] <- temp_tm
}
```
I will also rename some variable to increase readability
```{r}
merged <- merged %>% 
  dplyr::select(!c(Rk.y, Player.y, Pos.y, Age.y, MP.y, G.y, X,X.1)) %>%
  rename(Rk = Rk.x, Player = Player.x, Position = Pos.x, Age = Age.x, Game_played = G.x, FGpct = FG., X3Ppct = X3P., X2Ppct = X2P., eFGpct = eFG., FTpct = FT., TSpct = TS., ORBpct = ORB., DRBpct = DRB., TRBpct = TRB., ASTpct = AST., STLpct = STL., BLKpct = BLK., TOVpct = TOV., USGpct = USG., WSper48 = WS.48, Game_started = GS, MP = MP.x)
```

<!-- ```{r} -->
<!-- merged <- merged %>% -->
<!--   group_by(player_id) %>% -->
<!--   summarise( -->
<!--     Tm = Tm[length(Tm)], -->
<!--     Rk = Rk.x[1], -->
<!--     Player = Player.x[1], -->
<!--     Position = Pos.x[1], -->
<!--     Age = Age.x[1], -->
<!--     Game_played = sum(G.x), -->
<!--     Game_started = sum(GS), -->
<!--     MP = sum(MP.y) / sum(G.x), -->
<!--     FG = weighted.mean(FG, G.x), -->
<!--     FGA = weighted.mean(FGA, G.x), -->
<!--     FGpct = weighted.mean(FG., G.x), -->
<!--     X3P = weighted.mean(X3P, G.x), -->
<!--     X3PA = weighted.mean(X3PA, G.x), -->
<!--     X3Ppct = weighted.mean(X3P., G.x), -->
<!--     X2P = weighted.mean(X2P, G.x), -->
<!--     X2PA = weighted.mean(X2PA, G.x), -->
<!--     X2Ppct = weighted.mean(X2P., G.x), -->
<!--     eFGpct = weighted.mean(eFG., G.x), -->
<!--     FT = weighted.mean(FT, G.x), -->
<!--     FTA = weighted.mean(FTA, G.x), -->
<!--     FTpct = weighted.mean(FT., G.x), -->
<!--     ORB = weighted.mean(ORB, G.x), -->
<!--     DRB = weighted.mean(DRB, G.x), -->
<!--     TRB = weighted.mean(TRB, G.x), -->
<!--     AST = weighted.mean(AST, G.x), -->
<!--     STL = weighted.mean(STL, G.x), -->
<!--     BLK = weighted.mean(BLK, G.x), -->
<!--     TOV = weighted.mean(TOV, G.x), -->
<!--     PF = weighted.mean(PF, G.x), -->
<!--     PTS = weighted.mean(PTS, G.x), -->
<!--     PER = weighted.mean(PER, MP.x), -->
<!--     TSpct = weighted.mean(TS., G.x), -->
<!--     X3PAr = weighted.mean(X3PAr, G.x), -->
<!--     FTr = weighted.mean(FTr, G.x), -->
<!--     ORBpct = weighted.mean(ORB., G.x), -->
<!--     DRBpct = weighted.mean(DRB., G.x), -->
<!--     TRBpct = weighted.mean(TRB., G.x), -->
<!--     ASTpct = weighted.mean(AST., G.x), -->
<!--     STLpct = weighted.mean(STL., G.x), -->
<!--     BLKpct = weighted.mean(BLK., G.x), -->
<!--     TOVpct = weighted.mean(TOV., G.x), -->
<!--     USGpct = weighted.mean(USG., G.x), -->
<!--     OWS = sum(OWS), -->
<!--     DWS = sum(DWS), -->
<!--     WS = sum(WS), -->
<!--     WSper48 = weighted.mean(WS.48, MP.x), -->
<!--     OBPM = weighted.mean(OBPM, G.x), -->
<!--     DBPM = weighted.mean(DBPM, G.x), -->
<!--     BPM = weighted.mean(BPM, G.x), -->
<!--     VORP = mean(VORP) -->
<!--   ) -->
<!-- ``` -->
```{r, message=FALSE}
salary <- salary %>%
  group_by(Player, player_id, X2022.23) %>%
  summarise(Tm = Tm[1], Signed.Using = Signed.Using[1], Guaranteed = sum(as.numeric(grep(pattern = "[0-9]+",Guaranteed))), Rk = Rk[1])

merged <- merge(merged, salary, by = c("player_id"))
bio <- bio %>%
  dplyr::select(!Team) %>%
  rename(Player.x = Player)
merged <- merge(merged, bio, by = c("Player.x"), all.x=TRUE)
```

## Save table
```{r, eval=FALSE}
write.csv(merged, "dataset/all2022.csv")
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())
```

### Read in the saved table
```{r}
all <- as.data.frame(read.csv("dataset/all2022.csv"))
```
```{r}
dim(all)
```
There are `r dim(all)[1]` entries.
```{r}
str(all)
```

## Remove repeated variables


### Player Name
```{r}
sum(all$Player.x != all$Player.y)
```
Since there is no difference in the player name, I will remove player.y and renaming player.x to name 
```{r}
all <- all %>%
  dplyr::select(!Player.y) %>%
  rename(name = Player.x)
```

### Rank
It is rank in their original respective table (alphabetical order of player name in player statistics tables and salary in 2022-23 season for salary table).  
Since, it doesn't carry any extra information, I will remove both of the variables.  
```{r}
all <- all %>% dplyr::select(!c(Rk.x, Rk.y))
```

### Team
Tm.x is the team the player in in 2021-22 season while Tm.y is the team of 2022-23 season.  I will change Tm.x to team_2021 and Tm.y to team_2022.
```{r}
all <- all %>% rename(team_2021 = Tm.x, team_2022 = Tm.y)
```

# Exploratory analysis

## The response variable: salary
The aim of this project is to predict the salary next year. I will remove the salary of 2023-24 season onward and change the X2022.23 to numeric variables.  
```{r}
all <- all %>%
  rename(salary = X2022.23) %>%
  mutate(salary = as.numeric(str_extract(salary,"[0-9]+")))
```

```{r}
plot_ly(data=all, x = ~salary, type = "histogram", nbinsx = 30) %>%
  layout(title = "Frequency Diagram of NBA salary in 2022-23 season", xaxis = list(title = "yearly salary (USD)"), yaxis = list(title = "frequency"))
```
  
The salary is highly right skewed and there is high frequency concentrated on 0 to 2 million range. This might be because of the existence of minimum salary in NBA, which is 1 million to 3 million per year depending on their experience [@minSal22]. I will keep that in mind.  

```{r}
summary(all$salary)
```
```{r relvlpos, echo=FALSE}
all$Position <- factor(all$Position, levels = c("PG", "SG", "SF", "PF", "C"))
```


## Important Numeric Variables

I will first use the correlation with salary to get a feel on the numeric variables on the response variables

### Correlation with salary 2022-23

```{r}
numVar <- which(sapply(all, is.numeric))
numVarNames <- names(numVar)
length(numVarNames)
```
There are `r length(numVarNames)` numeric variables

```{r, fig.height= 12, fig.width=12}
all_numVar <- all[,numVar]
all_numVar <- dplyr::select(all_numVar, !X)

cor_Mat <- cor(all_numVar, use = "pairwise.complete.obs")

cor_names <- names(sort(cor_Mat[,"salary"], decreasing = TRUE))[1:20]

cor_Mat <- cor_Mat[cor_names, cor_names]

corrplot.mixed(cor_Mat, tl.pos = "lt")
```


### Points
Pts:

    Points per game

It has the highest correlation with salary among the numeric variables (`r cor_Mat["PTS", "salary"]`). It is the average point per game played.
```{r}
ggplotly(ggplot(all %>% drop_na(PTS, salary), aes(x = PTS, y = salary)) +
  geom_point(col = "blue") +
  geom_smooth(formula = y~x, method = "loess") +
  labs(title = "points per game in NBA 2021-22 vs salary in NBA 2022-23", x = "points per game", y = "yearly salary (USD)")
)
```
There is a clear linear correlation between salary and points per game. The correlation is smaller when the points per game is below about 9 but increase after it goes above 9 points.

```{r}
ggplotly(
  ggplot(all %>% drop_na(PTS, salary), aes(x = PTS)) +
    geom_histogram(bins = 30)+
    labs(title = "Frequency Distribution of points per game in NBA 2021-22", x = "points per game", y = "Frequency")
)
```


### Value Over Replacement player
Value Over Replacement Player:

    VORP - Value Over Replacement Player (available since the 1973-74 season in the NBA); a box score estimate of the points per 100 TEAM possessions that a player contributed above a replacement-level (-2.0) player, translated to an average team and prorated to an 82-game season.
    
Although FG, FGA, FT etc are more highly correlated, they are also highly correlated to points per game (> 0.75). I will look at the next one that is not highly correlated to points per game. It has a correlation of (`r cor_Mat["VORP", "salary"]`) with salary.  

```{r}
ggplotly(ggplot(all %>% drop_na(VORP, salary), aes(x = VORP, y = salary)) +
  geom_point(col = "blue") +
  geom_smooth(formula = y~x, method = "loess") +
  geom_smooth(formula = y~x, method = "glm", linetype = "dotted", col = "red", se= FALSE) +
  labs(title = "Value over replacement player in NBA 2021-22 vs salary in NBA 2022-23", x = "VORP", y = "yearly salary (USD)")
)
```
  
It shows clear linear correlation except some in both extreme of the VORP.

### Assists
Assists:

    Assists per game
    
It has a high correlation with salary while not a having such a high correlation with points per game. It has a correlation of (`r cor_Mat["AST", "salary"]`) with salary.
```{r}
ggplotly(ggplot(all %>% drop_na(AST, salary), aes(x = AST, y = salary)) +
  geom_point(col = "blue") +
  geom_smooth(formula = y~x, method = "loess") +
  geom_smooth(formula = y~x, method = "glm", linetype = "dotted", col = "red", se= FALSE) +
  labs(title = "Assists per game in NBA 2021-22 vs salary in NBA 2022-23", x = "Assists per game", y = "yearly salary (USD)")
)
```
  
It show positive correlation until it goes above 6 assists per game where it shows negative correlation. This maybe explained by that the players with high assist are usually not the first attacking choice of the team which might explain by they are pay less.

# Imputing missing data and factorising character variables.

## Impute missing data {.tabset}
```{r}
Nacol <- names(which(colSums(is.na(all) | all == "") > 0))
sort(colSums(sapply(all[Nacol], function(x) is.na(x) | x == "")), decreasing = TRUE)
```
### Salary
```{r}
kable(all[is.na(all$salary), c("X","name", "salary")])
```
The salary of `r all$name[is.na(all$salary)]` is 125000 USD @IshWainrightSal.
```{r}
all$salary[all$name == "Ish Wainright"] <- 125000
```


### Signed.Using
Signed.Using:

    The type of contract use to sign
    
I will impute by changing all NA to "None".
```{r}
unique(all$Signed.Using)

all$Signed.Using[grep("^1st [Rr]ound [Pp]ick",all$Signed.Using)] <- "1st round pick"
all$Signed.Using[grep("Cap [Ss]pace", all$Signed.Using)] <- "Cap space"
```


```{r}
all$Signed.Using[is.na(all$Signed.Using) | all$Signed.Using == ""] <- "None"

ggplotly(
  ggplot(all, aes(x = fct_reorder(as.factor(Signed.Using), salary, .fun = "mean"), y = salary, fill = Signed.Using)) +
    geom_boxplot()+
    geom_point(stat= "summary", fun = "mean")+
    labs(title = "Type of contract vs salary", x = "Type of contract", y = "yearly salary (USD)") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
```

### Height and Weight
```{r}
kable(all[which(is.na(all$Weight) | is.na(all$Height)), c("name", "Weight", "Height")])
```
I will manually search up their height and weight
```{r}
all$Weight[which(is.na(all$Weight))] <- c(190, 235, 290, 220, 226, 185, 225, 265, 290, 230, 218, 284, 260, 237, 175, 236, 250)

all$Height[which(is.na(all$Height))] <- c("7-0", "6-9", "7-3", "6-6", "6-7","6-7", "6-10","6-11", "6-11", "6-7", "6-8", "6-11", "6-10", "6-8", "6-4", "6-8", "6-11")
```

```{r}
heightinch <- as.numeric(sapply(all$Height, function(x) substring(x,1,1)))*12 + as.numeric(sapply(all$Height, function(x) substring(x, 3, nchar(x))))

all$Height <- heightinch
```
### X3Ppct
X3Ppct:
    
    3 point field goal percentage
    
```{r}
kable(all[which(is.na(all$X3Ppct)), c("name","X3P", "X3PA","X3Ppct")])
```
I will impute by setting to 0 if there is no 3 point attempt.
```{r}
all$X3Ppct[which(is.na(all$X3Ppct))] <- sapply(which(is.na(all$X3Ppct)), function(x) ifelse(all$X3PA[x] == 0, 0, all$X3P[x] / all$X3PA[x]))
```

```{r}
ggplotly(
  ggplot(all, aes(x = X3Ppct, y = salary)) +
    geom_point()+
    geom_smooth(col = "red", formula = y~x, method = "glm")+
    labs(title = "3 point percentage vs salary", x = "3 point field goal percentage", y = "yearly salary (USD)")
)
```
It shows a slight but not significant correlation between salary and 3 point percentage.

```{r}
ggplotly(
  ggplot(all, aes(x = X3Ppct, y = salary, col = Position))+
    geom_point()+
    geom_smooth(formula = y~x, method = "glm")+
    facet_grid(Position~.)+
    labs(title = "3 point percentage vs salary", x = "3 point field goal percentage", y = "yearly salary (USD)")
)
```
### Position
```{r}
kable(all[is.na(all$Position), c("name", "Position")])
```
I will impute manually by search up their primary position
```{r}
all$Position[is.na(all$Position)] <- c("SG", "SF", "PF", "SG", "PF", "SG", "PG", "PG")
```

### FTpct
FTpct:

    Free throw percentage
  
```{r}
kable(all[which(is.na(all$FTpct)), c("FT", "FTA", "FTpct")])
```
I will impute by setting to 0 if there is no free throw attempt.
```{r}
all$FTpct[which(is.na(all$FTpct))] <- sapply(which(is.na(all$FTpct)), function(x) ifelse(all$FTA[x] == 0, 0, all$FT[x] / all$FTA[x]))
```

```{r}
ggplotly(
  ggplot(all, aes(x = FTpct, y =salary))+
    geom_point()+
    geom_smooth(formula = y~x, method = "glm")+
    labs(title = "Free throw percentage vs salary", x = "free throw percentage", y = "yearly salary (USD)")
)
```

### Guaranteed
Guaranteed:

    The amount of a player's remaining salary that is guarenteed.
    
Since it is a direct indication of the salary, I will remove this variable.
```{r}
all <- dplyr::select(all, !Guaranteed)
```

## Factorizing Character Variables
Find all character variables: 
```{r}
chrVar <- names(which(sapply(all, is.character)))
chrVar
```
### Player Id and playe name
I will keep tempfor now to keep track of each entries but will remove them before fitting the model.  

### Team
```{r}
ggplotly(
  ggplot(all, aes(x = fct_reorder(as.factor(team_2021), salary, median,.desc = TRUE), y = salary, fill = reorder(as.factor(team_2021), salary, .fun = "mean", decreasing = TRUE))) +
    geom_boxplot()+
    labs(title = "Salary for each team", x = "team in 2021-22", y = "yearly salary in 2022-23 (USD)")+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))+
    guides(fill = guide_legend(title = "Team"))
)
ggplotly(
  ggplot(all, aes(x = fct_reorder(as.factor(team_2022), salary, median,.desc = TRUE), y = salary, fill = reorder(as.factor(team_2022), salary, .fun = "mean", decreasing = TRUE))) +
    geom_boxplot()+
    labs(title = "Salary for each team", x = "team in 2022-23", y = "yearly salary in 2022-23 (USD)")+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))+
    guides(fill = guide_legend(title = "Team"))
)
```

```{r}
all$team_2021 <- as.factor(all$team_2021)
all$team_2022 <- as.factor(all$team_2022)
```


### Signed.Using
I will also remove this variable as this might be a direct indication to the salary of the player.
```{r}
all <- dplyr::select(all, !Signed.Using)
```

# Visualization

## The response variable: salary
Although I have already done some visualisation, I will visualize it again.
```{r}
summary(all$salary)
ggplotly(
  ggplot(data = all, aes(x = salary))+
    geom_histogram(bins = 50)+
    labs(title = "Frequency distribution of salary", x = "yearly salary (USD)", y = "frequency")+
    theme_minimal()
)

ggplotly(
  ggplot(data = all, aes(x = "",y = salary))+
    geom_boxplot()+
    labs(y = "salary")+
    coord_flip()+
    theme_minimal()
)

g1 <- ggplot(all, aes(x = Age, y = salary))+
  geom_point(alpha = 0.7)+
  theme_minimal()+
  geom_smooth(formula = y~x, method = "glm")
  labs(title = "Age vs Salary")
ggMarginal(g1, type = "boxplot")
```

## Correlation with salary
```{r, fig.height= 12, fig.width=12}
numVarNames <- names(which(sapply(all, is.numeric)))
all_numVar <- all[, numVarNames]

cor_Mat <- cor(all_numVar)
salCor <- cor_Mat["salary",]

cor_names <- names(sort(salCor[which(abs(salCor) > 0.5)], decreasing = TRUE))

cor_Mat <- cor_Mat[cor_names, cor_names]

corrplot.mixed(cor_Mat, tl.pos = "lt", upper = "square")
```

## Grouping predictors


```{r}
pbio <- c("Age", "Height", "Weight")

attendence <- c("Game_played", "Game_started", "MP", "USGpct")

shooting <- c("FG", "FGA","FGpct","eFGpct", "PTS","TSpct")

X2_point <- c("X2P","X2PA","X2Ppct")

X3_point <- c("X3P","X3PA", "X3Ppct", "X3PAr")

Free_throw <- c("FT", "FTA", "FTpct", "FTr")

rebounding <- c("ORB", "DRB","TRB", "ORBpct", "DRBpct", "TRBpct")

playmaking <- c("AST", "TOV", "ASTpct", "TOVpct")

defence <- c("STL", "BLK", "PF", "STLpct", "BLKpct")

overall_adstats <- c("PER","OWS", "DWS", "WS", "WSper48", "OBPM", "DBPM", "BPM", "VORP")
```

### Player Bio
```{r}
all_bio <- melt(all, id.vars = "salary", measure.vars = pbio)

ggplot(all_bio, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")
```

### Attendence
```{r}
all_attendence <- melt(all, id.vars = "salary", measure.vars = attendence)

ggplot(all_attendence, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")
```

### Overall shooting
```{r}
all_ovSh <- melt(all, id.vars = "salary", measure.vars = shooting)

ggplot(all_ovSh, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")
```

I will remove FGpct as it is a data that is directly correlated to FG and FGA and it doesn't have large correlation to salary. I will remove effective field goal percentage as it is similar to true shooting percentage and it has less correlation.
```{r}
cor(all$FG, (all$FGA * all$FGpct))
all <- all %>% dplyr::select(!eFGpct, FGpct)
```

### 2 Pointers
```{r}
all_X2 <- melt(all,id.vars = "salary", measure.vars = X2_point)

ggplot(all_X2, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")
```

### 3 Pointers
```{r}
all_X3 <- melt(all, id.vars = "salary", measure.vars = X3_point)

ggplot(all_X3, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")
```

### Free throw
```{r}
all_ft <- melt(all, id.vars = "salary", measure.vars = Free_throw)

ggplot(all_ft, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")

```

### Rebounding
```{r}
all_rb <- melt(all, id.vars = "salary", measure.vars = rebounding)

ggplot(all_rb, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")

```

### Playmaking
```{r}
all_pm <- melt(all, id.vars = "salary", measure.vars = playmaking)

ggplot(all_pm, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")

```

### Defending
```{r}
all_df <- melt(all, id.vars = "salary", measure.vars = defence)

ggplot(all_df, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")

```

### Overall performance
```{r}
all_ovAd <- melt(all, id.vars = "salary", measure.vars = overall_adstats)

ggplot(all_ovAd, aes(x = value, y = salary)) + 
  geom_point()+
  geom_smooth(formula = y~x, method = glm)+
  facet_wrap(vars(variable), scales = "free")

```

# Feature Engineering


To reduce complexity of the model, I will combine and delete some variables. A high complexity model will result in overfitting.  
Before this, I will save a copy of original data
```{r, eval=FALSE}
write.csv(all[,!names(all) %in% c("X")], "dataset/cleaned_data.csv")
```
```{r}
rm(list=ls())
```
```{r, echo=FALSE}
all <- as.data.frame(read.csv("dataset/cleaned_data.csv"))
```
## Character variables

### Player Id and name
```{r}
players <- all[,c("player_id", "name")]
all <- dplyr::select(all, !c(player_id, name))
```

### Teams  
```{r}
cor(as.numeric(fct_reorder(as.factor(all$team_2021), all$salary, median)), all$salary)
cor(as.numeric(fct_reorder(as.factor(all$team_2022), all$salary, median)), all$salary)
```
  
There is no clear correlation between salary and team as each team will have varying salary for their star players and bench players. I will remove this variable.  
```{r}
all <- dplyr::select(all, !c(team_2021, team_2022))
```

## Importance of each variable

```{r}
quick_rf <- randomForest(salary~., data = all, ntree = 100, importance = TRUE)

imp_rf <- importance(quick_rf)
imp_df <- data.frame(Variables = row.names(imp_rf), MSE = imp_rf[,1])
imp_df <- imp_df[order(imp_df$MSE, decreasing = TRUE),]

ggplot(imp_df[1:20,], aes(x=reorder(Variables, MSE), y=MSE, fill=MSE)) + geom_bar(stat = 'identity') + labs(x = 'Variables', y= '% increase MSE if variable is randomly permuted') + coord_flip() + theme(legend.position="none")
```

## Net Possession Gained 
There are steal, block and offensive rebounds per game record but their correlation is not very strong. I will combine them into possession gain to make a stronger variable as these action will all result in a possession gain for the team.
```{r}
cor(all$STL, all$salary)
cor(all$BLK, all$salary)
cor(all$ORB, all$salary)
```
  
Removing steal, block and offensive rebounds per game and add possession gain.  
```{r}
all <- all %>%
  mutate(possGain = STL + BLK + ORB) %>%
  dplyr::select(!c(STL, BLK, ORB))
```

## Possession Lost
I will combine turn-overs and personal fouls to become possession. These variables have a low importance in the random forest. These actions will result in an possession lost.  
```{r}
imp_df$MSE[imp_df$Variables %in% c("TOV","PF")]
```
```{r}
all <- all %>%
  mutate(possLost = TOV + PF) %>%
  dplyr::select(!c(TOV, PF))
```


## field goal missed + remove field goal percentage and field goal attempt
I will remove anything about two pointer as it is just portion of field goal that is not three pointers.
```{r}
all <- all %>%
  dplyr::select(!c(X2P, X2PA, X2Ppct))
```

I will remove free throw, field goal and 3 point percentage and attempts. I will replace them by free throw, field goal and 3 three point missed.
```{r}
all <- all %>%
  mutate(FGM = FGA - FG, X3M = X3PA - X3P, FTM = FTA - FT) %>%
  dplyr::select(!c(FGA, FGpct, X3PA, X3Ppct, FTA, FTpct))
```

## Removing Game played and add starter
I will remove game started and replace it will starter. It will be define whether that player has start for more than 50% of their game played. I will also remove game played as it is directly related to minutes played while minutes played has a stronger correlation and importance. I will also change minutes play per game to minutes played in total
```{r}
all <- all %>%
  mutate(starter = ifelse(Game_started/Game_played >= 0.5, 1, 0), MP = MP * Game_played) %>%
  dplyr::select(!c(Game_started, Game_played))
all$starter <- as.factor(all$starter)
```

## Win share
I will remove win share and win share per 48 as it is just sum of defensive and offensive win share.  
```{r}
all <- dplyr::select(all, !c(WS, WSper48))
```

## Total rebound
I will remove total rebound as it is the sum of offensive and defensive rebound while defensive rebound has stronger correlation and importance.  
```{r}
all <-dplyr::select(all, !TRB)
```

## Box score
I will remove Box Plus or minus as it is the sum of offensive and defensive box score.
```{r}
cor(all[,c("OBPM", "DBPM", "BPM", "salary")])[,"salary"]
imp_df[imp_df$Variables %in% c("OBPM", "DBPM", "BPM"),]
cor(all$OBPM + all$DBPM, all$BPM)
```

```{r}
all$BPM <- NULL
```

## Free throw rate and three point rate
I will remove them as their are directly related to field goal and field goal missed.  
```{r}
all$FTr <- NULL
all$X3PAr <- NULL
```


# Preparing data for modelling
As I am not sure about the effect of the variables on the model, I will not remove any extra variable but look at the results first

```{r}
rm(list = ls()[!ls() %in% c("all", "players")] )
```

## Preprocessing predictor variables
```{r}
numVar <- names(which(sapply(all, is.numeric)))
salary <- all$salary
player_name <- all$name
numVar <- numVar[!numVar %in% c("salary", "X", "name")]
all_num <- all[, numVar]
all_fac <- all[,!names(all) %in% c(numVar, "salary", "name", "X")]
```
There are `r length(numVar)` numeric predictors and `r length(all_fac)` factor predictor.

### Removing skewness of variables
```{r}
log_names <- c()
minMax <- c()
sq_names <- c()
for (i in 1:ncol(all_num))
{
  if (any(all_num[,i] <= 0))
  {
    process <- preProcess(as.data.frame(all_num[,i]), method = "range")
    all_num[,i] <- predict(process, as.data.frame(all_num[,i]))
    minMax <- c(minMax, i)
  }
  if (skew(all_num[,i]) > 0.8)
  {
    all_num[,i] <- log(all_num[,i] + 1)
    log_names <- c(log_names, i)
  }
  else if(skew(all_num[,i]) < -0.8)
  {
    all_num[,i] <- all_num[,i]^2
    sq_names <- c(sq_names, i)
  }
}
log_names <- names(all_num)[log_names]
minMax_names <- names(all_num)[minMax]
sq_names <- names(all_num)[sq_names]
```
These column have been log + 1 due to its skewness.  
(The + 1 is to prevent logging 0 which result in NA)  

### Normalizing Data
```{r}
all_num[!names(all_num) %in% log_names] <- as.data.frame(scale(all_num[!names(all_num) %in% log_names]))
```

### One hot encoding for categorical variables
I will convert all the remaining variables to numeric (it is required by many machine learning algorithm).
```{r}
all_fac <- as.data.frame(model.matrix(~.-1, as.data.frame(all_fac)))
```

## Dealing with the skewness of response variable
```{r}
skew(salary)
```

```{r}
qqnorm(salary)
qqline(salary)
```


Salary is too right skewed and not normally distributed.  
```{r}
salary <- log(salary)
skew(salary)
```

```{r}
qqnorm(salary)
qqline(salary)
plot(x = 1:length(salary), y = sort(salary))
abline(h = 14)
```

### Combining data
I will remove the outlier (log(salary)) < 14
```{r}
alldata <- cbind(X = 1:nrow(all),name = players$name, salary = salary, all_num, all_fac)
alldata <- alldata[alldata$salary > 14,]
```

## Spliting training and testing set
```{r}
inTrain <- sample(c(TRUE, FALSE), size = nrow(alldata), prob = c(0.8, 0.2),replace = TRUE)
train <- alldata[inTrain,]
test <- alldata[!inTrain,]
```

```{r}
write.csv(alldata[,-1], "dataset/normalized_data.csv")
```


# Modelling


## Linear regression
```{r}
mod_lm <- lm(salary~.-name - X, data = train)
```

```{r}
plot(mod_lm, which = 1)
plot(mod_lm, which = 2)
plot(mod_lm, which = 3)
plot(mod_lm, which = 4)
abline(h = 4/nrow(train))
```

```{r}
sort(cooks.distance(mod_lm), decreasing = TRUE)[1:3]
players[as.numeric(names(which(cooks.distance(mod_lm) > 4/ nrow(train)))),]
```

```{r}
RMSE <- sqrt(sum(summary(mod_lm)$residuals^2)/nrow(train))
RMSE
summary(mod_lm)
```

```{r}
not_out <- !train$X %in% as.numeric(names(which(cooks.distance(mod_lm) > 4/ nrow(train))))
mod_lm_nOut <- lm(salary~.-name - X, data = train[not_out,])
```

```{r}
plot(mod_lm_nOut, which = 1)
plot(mod_lm_nOut, which = 2)
plot(mod_lm_nOut, which = 3)
plot(mod_lm_nOut, which = 4)
abline(h = 4/nrow(train))
```
```{r}
mod_lm_noPos <- lm(salary~. -1 -name -X -PositionPG -PositionSG - PositionSF-PositionPF-PositionC, data = train)
RMSE <- sqrt(sum(summary(mod_lm_noPos)$residuals^2)/nrow(train))
RMSE
summary(mod_lm_noPos)
```

## Lasso regression
```{r}
train_control <- trainControl(method = "repeatedcv", number = 5)
param_grid <- expand.grid(alpha = 1, lambda = seq(0.001,0.1, by = 0.0005))

mod_lasso <- train(salary~.-1-name-X, data = train, method = "glmnet", trControl = train_control, tuneGrid = param_grid)
```

```{r}
mod_lasso$bestTune
coef(mod_lasso$finalModel, mod_lasso$bestTune$lambda)
```

```{r}
coef_nonZero <- which(coef(mod_lasso$finalModel, mod_lasso$bestTune$lambda) != 0) + 2
```

```{r}
mod_lm_lasso <- lm(salary~., train[,coef_nonZero])

RMSE <- sqrt(sum(summary(mod_lm_noPos)$residuals^2)/nrow(train))
RMSE
summary(mod_lm_lasso)
```

## Step AIC
```{r}
mod_stepAIC <- stepAIC(mod_lm, scope = list(upper = ~., lower = ~1),trace = FALSE)
```
```{r}
mod_stepAIC$coefficients
rmse(mod_stepAIC$fitted.values, train$salary)
rmse(predict(mod_stepAIC, test), test$salary)
```
## Decision Tree
```{r}
mod_dt <- rpart(salary~., data = train[,-c(1,2)])
```

```{r}
rmse(train$salary,predict(mod_dt))
tab <- printcp(mod_dt)
rsq <- 1- tab[,c(3,4)]
rsq
```

```{r}
pred <- predict(mod_dt, test)
rmse(test$salary, pred)
```
  
## Random Forest
```{r}
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry, ntree = c(100,500,1000,1500,2000,5000))
mod_rf <- randomForest(salary~., data = train[,-c(1,2)], ntree = 5000,maxnodes = 100, trControl = trainControl(method = "repeatedcv", repeats = 10, number = 5), tuneGrid = tunegrid)
```

```{r}
pred_rf_tr <- predict(mod_rf, train)
rmse(pred_rf_tr, train$salary)

pred_rf <- predict(mod_rf, test)
rmse(pred_rf, test$salary)
```

```{r}
mod_rft <- train(salary~., train[,-c(1,2)], method = "rf", trControl = trainControl(method = "repeatedcv", number = 10, repeats = 5))
rmse(predict(mod_rft, train), train$salary)
rmse(predict(mod_rft, test), test$salary)
```
## PCA

## Neural Network
